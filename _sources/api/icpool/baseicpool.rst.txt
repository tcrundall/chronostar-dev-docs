==========
BaseICPool
==========

The abstract base class for initial conditions pool objects.
These objects manage a pool of initial conditions which :class:`Model` uses to initialise a fit.


.. class:: BaseICPool

    A pool (or priority queue?) of initial conditions that can be used to initialise model fits.

    Calling :func:`~BaseICPool.pool` returns an iterator that can be iterated over, yielding a set of initial conditions. By registering the result of each fit with the :func:`~BaseICPool.register_result`, ICPool can use this information to generate the next set of initial conditions.

    :param component_class: A Class that either inherits from BaseComponent or matches the interface. This Class encapsulates the parametrisation of a single component.
    :type Component: subclass(BaseComponent)
    :param inserter_class: A Class that either inherits from BaseInserter or matches the interface exactly. This Class handles the initialisation of the next set of models. For example, if we have just fit a collection of models with N components, `inserter_class` will generate a set of initial conditions for `N+1` components.
    :type Inserter: subclass(BaseInserter)

    .. method:: __init__(component_class, inserter_class)

        Constructor method

    .. attribute:: registry

        A record of best models and associated scores from fits initialised with conditions generated by this class.

        :type: dict[key, tuple[Model, float]]

    .. method:: pool()
        :abstractmethod:

        Produce a pool of initial conditions that can be iterated over, yielding the next most promising initial conditions, along with a unique identifier.

        :return: A generator that can be iterated over, yielding the next most promising initial conditions.
        :rtype: generator

    .. method:: register_result(unique_id, model, score)
        :abstractmethod:

        Once a fit has converged, use this method to register its resulting model and score.

        :param unique_id: the id that was generated along with a set of initial conditions.
        :type unique_id: int
        :param model: the best fitting model corresponding to a set of initial conditions
        :type model: list[float]
        :param score: the score of the best fit model
        :type score: float

    .. method:: get_best_mixture()
        :abstractmethod:

        Find best mixture from fit history

        :return: A mixture model
        :rtype: subclass(class:`ChronBaseMixture`)
