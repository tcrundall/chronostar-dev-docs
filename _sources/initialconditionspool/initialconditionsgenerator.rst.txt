============================
Initial Conditions Generator
============================

Manages the generation of each generation of initial conditions, based on 
the performance of the previous generation. For example, a Gaussian Mixture 
Model is a linear combination of `N` components. The ICG would use the 
performance of all attempts made with `N` components, and using some user 
definable approach, would generate the next set of `N + k` component models.

In order to be extremely general, the ICG is an actual *generator* wrapped 
around an ojbect that does the actual generation... these notes aren't very 
clear, but I promise you the end result will be extremely cool, flexible, and 
very straightforward to parallelise.

inputs:

- config params

injected dependencies:

- Component Class
- Component Inserter

The interface is defined as follows:

.. class:: InitialConditionsGenerator

    The top level driver that manages the overall fit to data, accounting for
    high-level parameters, such as number of components. It also (ideally) will 
    handle the management of MPIPool processes.

    .. method:: __init__(self, component_class, inserter_class)

        Initialise an InitialConditionsGenerator objects.

        :param component_class: A Class that either inherits from BaseComponent or matches the interface. This Class encapsulates the parametrisation of a single component.
        :type component_class: subclass(BaseComponent)
        :param inserter_class: A Class that either inherits from BaseInserter or matches the interface exactly. This Class handles the initialisation of the next set of models. For example, if we have just fit a collection of models with N components, `inserter_class` will generate a set of initial conditions for `N+1` components.
        :type inserter_class: subclass(BaseInserter)

    .. attribute:: pars_registry

        A record of best fitting parameters resulting from fits initialised with conditions generated by this class.

        :type: dict[key, list[floats]]

    .. attribute:: score_registry

        A record of scores resulting from fits initialised with conditions generated by this class.

        :type: dict[key, floats]


    .. method:: initial_conditions(self)

        Produce a generator that can be iterated over, yielding the next most promising initial conditions, along with a unique identifier.

        :return: A generator that can be iterated over, yielding the next most promising initial conditions.
        :rtype: generator

    .. method:: register_result(self, unique_id, parameters, score)

        Once a fit has converged, use this method to register its resulting parameters and score.

        :param unique_id: some id that was generated along with a set of initial conditions.
        :type unique_id: int
        :param parameters: the best fitting parameters correspond to a set of initial conditions
        :type parameters: list[float]
        :param score: the score of the best fit model
        :type score: float

Example Usage
-------------

The usage will look something like this::

  icg = InitialConditionsGenerator(SphereComponent, LazyInserter)

  for ident, init_conds in icg.initial_conditions():
    m = Model(init_conds) 
    m.fit(data)
    icg.register_result(ident, m.params, my.bic(data))

  # loop will end when icg is no longer able to generate reasonable initial conditions
  best_model = icg.best_model()

See? So elegant. Behind the scenes, the ICG is bookkeeping which models 
performed the best, and therefore which models are the best candidates for 
further exploration. The ICG can be as clever or as simple as the user 
desires. The method of how a new component is introduced is also left 
completely free.

Suggested implementation
-------------------------

A *serial* ICG implementation could look a little like this::
  
  class InitialConditionsGenerator():

    def __init__(self, ComponentClass, InsertionApproach):
      self.component_class = ComponentClass
      self.insertion_approach = InsertionApproach

    def initial_conditions(self):

      best_model = None
      prev_best_score = None
      best_score = -np.inf
      while prev_best_score is None or best_score > prev_best_score:
        prev_best_score = best_score
        self.pars_registry = {}
        self.score_registry = {}

        # Loop over the next generation of initial conditions
        for ix, init_conditions in enumerate(self.insertion_approach.next_gen(best_model)):
          yield ix, init_conditions

        # Once all initial conditions are provided, look for best one in registry
        best_ix = max(self.score_registry, key=self.score_registry.get)
        best_model = self.pars_registry[best_ix]
        best_score = self.score_registry[best_ix]

        # Using best fit, repeat until score ceases to improve

    def register_result(self, ident, parameters, score):
      self.pars_registry[ident] = parameters
      self.score_registry[ident] = score

Ok, maybe not so simple now... but still a promising approach, I think.


